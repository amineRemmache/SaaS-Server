# -*- mode: ruby -*-
# vi: set ft=ruby :

ENV['VAGRANT_NO_PARALLEL'] = 'yes'

require 'ipaddr'

def get_or_generate_k3s_token
  # TODO generate an unique random an cache it.
  # generated with openssl rand -hex 32
  '7e982a7bbac5f385ecbb988f800787bc9bb617552813a63c4469521c53d83b6e'
end

# see https://get.k3s.io/
# see https://update.k3s.io/v1-release/channels
# see https://github.com/k3s-io/k3s/releases
k3s_channel = 'latest'
k3s_version = 'v1.25.2+k3s1'
# see https://github.com/helm/helm/releases
helm_version = 'v3.10.0'
# see https://github.com/roboll/helmfile/releases
helmfile_version = 'v0.144.0'
# see https://github.com/kubernetes/dashboard/releases
k8s_dashboard_version = 'v2.7.0'
# see https://github.com/derailed/k9s/releases
k9s_version = 'v0.26.6'
# see https://github.com/kubernetes-sigs/krew/releases
krew_version = 'v0.4.3'
# see https://github.com/etcd-io/etcd/releases
# NB make sure you use a version compatible with k3s.
etcdctl_version = 'v3.5.5'
# see https://gitlab.com/gitlab-org/charts/gitlab-runner/-/tags
gitlab_runner_chart_version = '0.44.0'
# link to the gitlab-vagrant environment (https://github.com/rgl/gitlab-vagrant running at ../gitlab-vagrant).
gitlab_fqdn = 'gitlab.example.com'
gitlab_ip = '10.10.9.99'

# set the flannel backend. use one of:
# * host-gw:   non-secure network (needs ethernet (L2) connectivity between nodes).
# * wireguard:     secure network (needs UDP (L3) connectivity between nodes).
flannel_backend = 'host-gw'

VAGRANT_BOX         = "jj-ucll/debian11"
VAGRANT_BOX_VERSION = "0.0.1"
# VAGRANT_BOX         = "generic/ubuntu2204"
# VAGRANT_BOX_VERSION = "4.1.16"
CPUS_MASTER_NODE    = 2
CPUS_WORKER_NODE    = 4
MEMORY_MASTER_NODE  = 2048
MEMORY_WORKER_NODE  = 4024
WORKER_NODES_COUNT  = 2


Vagrant.configure(2) do |config|
  config.vm.synced_folder ".", "/vagrant"
  config.vm.provision "shell", path: "bootstrap.sh"
  

  # Kubernetes Master Server
  config.vm.define "kmaster" do |node|
    
    node.vm.box               = VAGRANT_BOX
    node.vm.box_check_update  = false
    node.vm.box_version       = VAGRANT_BOX_VERSION
    node.vm.hostname          = "kmaster.insim.dz"


    # node.vm.network "private_network", ip: "172.16.16.100"
    config.vm.network "public_network", ip: "192.168.1.210"
  
    node.vm.provider :virtualbox do |v|
      v.name    = "kmaster"
      v.memory  = MEMORY_MASTER_NODE
      v.cpus    = CPUS_MASTER_NODE
    end
  
    node.vm.provider :libvirt do |v|
      v.memory  = MEMORY_MASTER_NODE
      v.nested  = true
      v.cpus    = CPUS_MASTER_NODE
    end
  
    node.vm.provision "shell", path: "bootstrap_kmaster.sh"
  
  end


  # Kubernetes Worker Nodes
  (1..WORKER_NODES_COUNT).each do |i|

    config.vm.define "kworker#{i}" do |node|

      node.vm.box               = VAGRANT_BOX
      node.vm.box_check_update  = false
      node.vm.box_version       = VAGRANT_BOX_VERSION
      node.vm.hostname          = "kworker#{i}.insim.dz"

      # node.vm.network "private_network", ip: "172.16.16.10#{i}"
      config.vm.network "public_network", ip: "192.168.1.21#{i}"

      node.vm.provider :vmware_workstation do |v|
        v.name    = "kworker#{i}"
        v.memory  = MEMORY_WORKER_NODE
        v.cpus    = CPUS_WORKER_NODE
      end

      node.vm.provider :libvirt do |v|
        v.memory  = MEMORY_WORKER_NODE
        v.nested  = true
        v.cpus    = CPUS_WORKER_NODE
      end

      node.vm.provision "shell", path: "bootstrap_kworker.sh", :args => [node.vm.hostname]wwwwwwww

    end

  end

end
wwwwwwwww